"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const jsonfile_1 = require("jsonfile");
const path_1 = require("path");
const util_1 = require("util");
const config_1 = require("../config");
const command_constants_1 = require("../constants/command.constants");
const messages_constants_1 = require("../constants/messages.constants");
const data_1 = require("../libs/data");
const process_manager_1 = require("../libs/process-manager");
const server_1 = require("../libs/server");
const utils_1 = require("../libs/utils");
class Start extends command_1.Command {
    async run() {
        const { flags: userFlags } = this.parse(Start);
        const environmentInfoList = await this.getEnvironmentInfoList(userFlags);
        try {
            for (const environmentInfo of environmentInfoList) {
                await this.validatePort(environmentInfo.port, environmentInfo.hostname);
                await this.validateName(environmentInfo.name);
                await this.runEnvironment(environmentInfo, userFlags['daemon-off']);
            }
        }
        catch (error) {
            this.error(error.message);
        }
        finally {
            process_manager_1.ProcessManager.disconnect();
        }
    }
    async runEnvironment(environmentInfo, daemonOff = false) {
        if (daemonOff) {
            this.startForegroundProcess(environmentInfo);
        }
        else {
            await this.startManagedProcess(environmentInfo);
        }
    }
    async addProcessToProcessListManager(environmentInfo, process) {
        await process_manager_1.ProcessListManager.addProcess({
            name: environmentInfo.name,
            port: environmentInfo.port,
            hostname: environmentInfo.hostname,
            endpointPrefix: environmentInfo.endpointPrefix,
            pid: process[0].pm2_env.pm_id
        });
    }
    logStartedProcess(environmentInfo, process) {
        const hostname = environmentInfo.hostname === '0.0.0.0'
            ? 'localhost'
            : environmentInfo.hostname;
        this.log(messages_constants_1.Messages.CLI.PROCESS_STARTED, environmentInfo.protocol, hostname, environmentInfo.port, process[0].pm2_env.pm_id, process[0].pm2_env.name);
    }
    /**
     * Start the mock server and run it in the same process in the foreground.
     * We don't use PM2 here to manage the process
     *
     * @param environmentInfo
     * @returns
     */
    startForegroundProcess(environmentInfo) {
        const parameters = {
            data: environmentInfo.dataFile,
            environmentDir: environmentInfo.initialDataDir
                ? environmentInfo.initialDataDir
                : '',
            logTransaction: environmentInfo.logTransaction,
            fileTransportsOptions: [
                { filename: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-out.log`) }
            ]
        };
        (0, server_1.createServer)(parameters);
    }
    /**
     * Start the mock server and manage the process with PM2
     *
     * @param environmentInfo
     * @returns
     */
    async startManagedProcess(environmentInfo) {
        const args = ['--data', environmentInfo.dataFile];
        if (environmentInfo.initialDataDir) {
            args.push('--environmentDir', environmentInfo.initialDataDir);
        }
        if (environmentInfo.logTransaction) {
            args.push('--logTransaction');
        }
        const process = await process_manager_1.ProcessManager.start({
            max_restarts: 1,
            wait_ready: true,
            min_uptime: 10000,
            kill_timeout: 2000,
            args,
            error: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-error.log`),
            output: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-out.log`),
            name: environmentInfo.name,
            script: (0, path_1.resolve)(__dirname, '../libs/server-start-script.js'),
            exec_mode: 'fork'
        });
        if (process[0].pm2_env.status === 'errored') {
            // if process is errored we want to delete it
            await this.handleProcessError(environmentInfo.name);
        }
        this.logStartedProcess(environmentInfo, process);
        await this.addProcessToProcessListManager(environmentInfo, process);
    }
    async handleProcessError(name) {
        // if process is errored we want to delete it
        await process_manager_1.ProcessManager.delete(name);
        this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PROCESS_START_LOG_ERROR, name, name));
    }
    async getEnvironmentInfoList(userFlags) {
        // We are in a container, env file is ready and relative to the Dockerfile
        if (userFlags.container) {
            return this.getEnvInfoListFromContainerFlag(userFlags);
        }
        return this.getEnvInfoListFromNonContainerFlag(userFlags);
    }
    async getEnvInfoListFromContainerFlag(userFlags) {
        const environment = await (0, jsonfile_1.readFile)(userFlags.data, 'utf-8');
        let protocol = 'http';
        if (environment.tlsOptions.enabled) {
            protocol = 'https';
        }
        return [
            {
                protocol,
                dataFile: userFlags.data,
                name: environment.name,
                hostname: environment.hostname,
                port: environment.port,
                endpointPrefix: environment.endpointPrefix,
                initialDataDir: null,
                logTransaction: userFlags['log-transaction']
            }
        ];
    }
    async getEnvInfoListFromNonContainerFlag(userFlags) {
        const environments = await (0, data_1.parseDataFile)(userFlags.data);
        if (userFlags.all) {
            return this.getEnvInfoFromEnvironments(userFlags, environments);
        }
        return this.getEnvInfoFromUserChoice(userFlags, environments);
    }
    async getEnvInfoFromEnvironments(userFlags, environments) {
        const environmentInfoList = [];
        for (let envIndex = 0; envIndex < environments.length; envIndex++) {
            try {
                const environmentInfo = await (0, data_1.prepareData)({
                    environments,
                    options: {
                        index: envIndex,
                        name: environments[envIndex].name,
                        port: environments[envIndex].port,
                        endpointPrefix: environments[envIndex].endpointPrefix
                    },
                    repair: userFlags.repair
                });
                environmentInfoList.push(Object.assign(Object.assign({}, environmentInfo), { initialDataDir: (0, utils_1.getDirname)(userFlags.data), logTransaction: userFlags['log-transaction'] }));
            }
            catch (error) {
                this.error(error.message);
            }
        }
        return environmentInfoList;
    }
    async getEnvInfoFromUserChoice(userFlags, environments) {
        userFlags = await (0, utils_1.promptEnvironmentChoice)(userFlags, environments);
        let environmentInfo;
        try {
            environmentInfo = await (0, data_1.prepareData)({
                environments,
                options: {
                    index: userFlags.index,
                    name: userFlags.name,
                    port: userFlags.port,
                    hostname: userFlags.hostname,
                    endpointPrefix: userFlags.endpointPrefix,
                    pname: userFlags.pname
                },
                repair: userFlags.repair
            });
        }
        catch (error) {
            this.error(error.message);
        }
        return [
            Object.assign(Object.assign({}, environmentInfo), { initialDataDir: (0, utils_1.getDirname)(userFlags.data), logTransaction: userFlags['log-transaction'] })
        ];
    }
    async validateName(name) {
        const runningProcesses = await process_manager_1.ProcessManager.list();
        const processNamesList = runningProcesses.map((process) => process.name);
        if (processNamesList.includes(name)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PROCESS_NAME_USED_ERROR, name));
        }
    }
    async validatePort(port, hostname) {
        if (!(0, utils_1.portIsValid)(port)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_IS_NOT_VALID, port));
        }
        if (await (0, utils_1.portInUse)(port, hostname)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_ALREADY_USED, port));
        }
    }
}
exports.default = Start;
Start.description = 'Start a mock API';
Start.examples = [
    '$ mockoon-cli start --data ~/data.json',
    '$ mockoon-cli start --data ~/data.json --index 0',
    '$ mockoon-cli start --data https://file-server/data.json --index 0',
    '$ mockoon-cli start --data ~/data.json --name "Mock environment"',
    '$ mockoon-cli start --data ~/data.json --name "Mock environment" --pname "proc1"',
    '$ mockoon-cli start --data ~/data.json --all',
    '$ mockoon-cli start --data ~/data.json --daemon-off',
    '$ mockoon-cli start --data ~/data.json --log-transaction'
];
Start.flags = Object.assign(Object.assign(Object.assign({}, command_constants_1.commonFlags), command_constants_1.startFlags), { pname: command_1.flags.string({
        char: 'N',
        description: 'Override the process name'
    }), hostname: command_1.flags.string({
        char: 'l',
        description: 'Listening hostname/address'
    }), 'daemon-off': command_1.flags.boolean({
        char: 'D',
        description: 'Keep the CLI in the foreground and do not manage the process with PM2',
        default: false,
        exclusive: ['all']
    }), 
    /**
     * /!\ Undocumented flag.
     * Mostly for internal use when `start `command is called during
     * a Docker image build.
     *
     * When using the `dockerize` command, file loading, validity checks,
     * migrations, etc. are all performed, and the single environment is
     * extracted in a separated file next to the generated Dockerfile.
     * It's easier to directly provide this file to the `start` command run
     * from the Dockerfile when building the Docker image rather than
     * having the image build failing due to a failure in the `start` command.
     */
    container: command_1.flags.boolean({
        char: 'c',
        hidden: true
    }) });
//# sourceMappingURL=start.js.map