"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const inquirer = require("inquirer");
const command_constants_1 = require("../constants/command.constants");
const messages_constants_1 = require("../constants/messages.constants");
const data_1 = require("../libs/data");
const process_manager_1 = require("../libs/process-manager");
const utils_1 = require("../libs/utils");
class Stop extends command_1.Command {
    async run() {
        const { args } = this.parse(Stop);
        let relistProcesses = false;
        let processesToStop = [];
        const processes = await process_manager_1.ProcessManager.list();
        if (processes.length === 0) {
            this.log(messages_constants_1.Messages.CLI.NO_RUNNING_PROCESS);
            process_manager_1.ProcessManager.disconnect();
            return;
        }
        // prompt for process name or id
        if (args.id === undefined) {
            const response = await inquirer.prompt([
                {
                    name: 'process',
                    message: 'Please select a process',
                    type: 'list',
                    choices: processes.map((process) => ({
                        name: process.name || process.pid
                    }))
                }
            ]);
            processesToStop.push(response.process);
        }
        else if (args.id === 'all') {
            // list all mockoon's processes to stop
            processesToStop = processes.reduce((processes1, process) => {
                const nameOrId = process.name || process.pm_id;
                if (nameOrId !== undefined) {
                    processes1.push(nameOrId);
                }
                return processes1;
            }, []);
        }
        else {
            processesToStop.push(args.id);
        }
        for (const processToStop of processesToStop) {
            try {
                // typing is wrong, delete() returns an array
                const stoppedProcesses = (await process_manager_1.ProcessManager.delete(processToStop));
                // verify that something has been stopped
                stoppedProcesses.forEach((stoppedProcess) => {
                    if (stoppedProcess !== undefined) {
                        this.log(messages_constants_1.Messages.CLI.PROCESS_STOPPED, stoppedProcess.pm_id, stoppedProcess.name);
                        process_manager_1.ProcessListManager.deleteProcess(stoppedProcess.name);
                    }
                });
            }
            catch (error) {
                if (error.message === 'process name not found' && args.id === 'all') {
                    // if 'all' was specified and no process was stopped, do not list and immediately exit
                    this.log(messages_constants_1.Messages.CLI.NO_RUNNING_PROCESS);
                }
                else {
                    this.error(error.message, { exit: false });
                    relistProcesses = true;
                }
            }
        }
        try {
            const runningProcesses = await process_manager_1.ProcessManager.list();
            if (relistProcesses) {
                if (runningProcesses.length) {
                    this.log(messages_constants_1.Messages.CLI.RUNNING_PROCESSES);
                    (0, utils_1.logProcesses)(runningProcesses);
                }
                else {
                    this.log(messages_constants_1.Messages.CLI.NO_RUNNING_PROCESS);
                }
            }
            // always clean data files after a stop
            await (0, data_1.cleanDataFiles)(runningProcesses);
        }
        catch (error) {
            this.error(error.message, { exit: false });
        }
        process_manager_1.ProcessManager.disconnect();
    }
}
exports.default = Stop;
Stop.description = 'Stop a mock API';
Stop.examples = [
    '$ mockoon-cli stop',
    '$ mockoon-cli stop 0',
    '$ mockoon-cli stop "name"',
    '$ mockoon-cli stop "all"'
];
Stop.flags = Object.assign({}, command_constants_1.commonFlags);
Stop.args = [
    {
        name: 'id',
        description: 'Running API pid or name',
        required: false
    }
];
//# sourceMappingURL=stop.js.map