"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const fs_1 = require("fs");
const mkdirp = require("mkdirp");
const mustache_1 = require("mustache");
const path_1 = require("path");
const util_1 = require("util");
const config_1 = require("../config");
const command_constants_1 = require("../constants/command.constants");
const docker_constants_1 = require("../constants/docker.constants");
const messages_constants_1 = require("../constants/messages.constants");
const data_1 = require("../libs/data");
const utils_1 = require("../libs/utils");
class Dockerize extends command_1.Command {
    async run() {
        let { flags: userFlags } = this.parse(Dockerize);
        const resolvedDockerfilePath = (0, path_1.resolve)(userFlags.output);
        const dockerfilePath = (0, path_1.parse)(resolvedDockerfilePath);
        let environmentInfo;
        const environments = await (0, data_1.parseDataFile)(userFlags.data);
        userFlags = await (0, utils_1.promptEnvironmentChoice)(userFlags, environments);
        try {
            environmentInfo = await (0, data_1.prepareData)({
                environments,
                options: {
                    index: userFlags.index,
                    name: userFlags.name,
                    port: userFlags.port
                },
                dockerfileDir: dockerfilePath.dir,
                repair: userFlags.repair
            });
        }
        catch (error) {
            this.error(error.message);
        }
        if (!(0, utils_1.portIsValid)(environmentInfo.port)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_IS_NOT_VALID, environmentInfo.port));
        }
        try {
            const dockerFile = (0, mustache_1.render)(docker_constants_1.DOCKER_TEMPLATE, {
                port: environmentInfo.port,
                filePath: (0, path_1.parse)(environmentInfo.dataFile).base,
                version: config_1.Config.version,
                // passing more args to the dockerfile template, only make sense for log transaction yet as other flags are immediately used during the file creation and data preparation
                args: userFlags['log-transaction'] ? ', "--log-transaction"' : ''
            });
            await mkdirp(dockerfilePath.dir);
            await fs_1.promises.writeFile(resolvedDockerfilePath, dockerFile);
            this.log(messages_constants_1.Messages.CLI.DOCKERIZE_SUCCESS, resolvedDockerfilePath);
            this.log(messages_constants_1.Messages.CLI.DOCKERIZE_BUILD_COMMAND, dockerfilePath.dir, environmentInfo.name, environmentInfo.port, environmentInfo.port, environmentInfo.name);
        }
        catch (error) {
            this.error(error.message);
        }
    }
}
exports.default = Dockerize;
Dockerize.description = 'Create a Dockerfile to build a self-contained image of a mock API';
Dockerize.examples = [
    '$ mockoon-cli dockerize --data ~/data.json --output ./Dockerfile',
    '$ mockoon-cli dockerize --data ~/data.json --index 0 --output ./Dockerfile',
    '$ mockoon-cli dockerize --data https://file-server/data.json --index 0 --output ./Dockerfile',
    '$ mockoon-cli dockerize --data ~/data.json --name "Mock environment" --output ./Dockerfile'
];
Dockerize.flags = Object.assign(Object.assign(Object.assign({}, command_constants_1.commonFlags), command_constants_1.startFlags), { output: command_1.flags.string({
        char: 'o',
        description: 'Generated Dockerfile path and name (e.g. `./Dockerfile`)',
        required: true
    }) });
//# sourceMappingURL=dockerize.js.map