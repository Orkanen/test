"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanDataFiles = exports.prepareData = exports.parseDataFile = void 0;
const commons_1 = require("@mockoon/commons");
const axios_1 = require("axios");
const fs_1 = require("fs");
const inquirer_1 = require("inquirer");
const jsonfile_1 = require("jsonfile");
const mkdirp = require("mkdirp");
const path_1 = require("path");
const util_1 = require("util");
const config_1 = require("../config");
const messages_constants_1 = require("../constants/messages.constants");
const utils_1 = require("./utils");
/**
 * Load and parse a JSON data file.
 * Supports both export files (with one or multiple envs) or new environment files.
 *
 * @param filePath
 */
const parseDataFile = async (filePath) => {
    let loadedData;
    if (filePath.indexOf('http') !== 0) {
        loadedData = await (0, jsonfile_1.readFile)(filePath, 'utf-8');
    }
    else {
        const { data: responseData } = await axios_1.default.get(filePath, {
            timeout: 30000
        });
        loadedData =
            typeof responseData === 'string'
                ? JSON.parse(responseData)
                : responseData;
    }
    const environments = [];
    // we have an export file
    if ('source' in loadedData && 'data' in loadedData) {
        // Extract all environments, eventually filter items of type 'route'
        loadedData.data.forEach((dataItem) => {
            if (dataItem.type === 'environment') {
                environments.push(dataItem.item);
            }
        });
    }
    else if (typeof loadedData === 'object') {
        environments.push(loadedData);
    }
    if (environments.length === 0) {
        throw new Error(messages_constants_1.Messages.CLI.ENVIRONMENT_NOT_AVAILABLE_ERROR);
    }
    return environments;
};
exports.parseDataFile = parseDataFile;
/**
 * Check if an environment can be run by the CLI and
 * migrate it if needed.
 * Validate the environment schema (will automatically repair)
 *
 * @param environment
 */
const migrateAndValidateEnvironment = async (environment, environmentName, forceRepair) => {
    // environment data are too old: lastMigration is not present
    if (environment.lastMigration === undefined && !forceRepair) {
        const promptResponse = await (0, inquirer_1.prompt)([
            {
                name: 'repair',
                message: `${environmentName ? '"' + environmentName + '"' : 'This environment'} does not seem to be a valid Mockoon environment or is too old. Let Mockoon attempt to repair it?`,
                type: 'confirm',
                default: true
            }
        ]);
        if (!promptResponse.repair) {
            throw new Error(messages_constants_1.Messages.CLI.DATA_TOO_OLD_ERROR);
        }
    }
    // environment data migrated with a more recent version (if installed CLI version does not include @mockoon/commons with required migrations)
    if (environment.lastMigration > commons_1.HighestMigrationId) {
        throw new Error(messages_constants_1.Messages.CLI.DATA_TOO_RECENT_ERROR);
    }
    try {
        // apply migrations
        commons_1.Migrations.forEach((migration) => {
            if (migration.id > environment.lastMigration) {
                migration.migrationFunction(environment);
            }
        });
    }
    catch (error) {
        environment.lastMigration = commons_1.HighestMigrationId;
    }
    const validatedEnvironment = commons_1.EnvironmentSchema.validate(environment).value;
    return validatedEnvironment;
};
/**
 * Check if data file is in the new format (with data and source)
 * and return the environment by index or name
 *
 * @param data
 * @param options
 */
const getEnvironment = (environments, options) => {
    let findError;
    // find environment by index
    if (options.index !== undefined && environments[options.index]) {
        return environments[options.index];
    }
    else {
        findError = (0, util_1.format)(messages_constants_1.Messages.CLI.ENVIRONMENT_NOT_FOUND_INDEX_ERROR, options.index);
    }
    // find by name
    if (options.name) {
        const foundEnvironment = environments.find((environment) => environment.name === options.name);
        if (foundEnvironment) {
            return foundEnvironment;
        }
        else {
            findError = (0, util_1.format)(messages_constants_1.Messages.CLI.ENVIRONMENT_NOT_FOUND_NAME_ERROR, options.name);
        }
    }
    throw new Error(findError);
};
/**
 * Load the data file, find and migrate the environment
 * copy the environment to a new temporary file.
 *
 * @param environments - path to the data file or export data
 * @param options
 */
const prepareData = async (parameters) => {
    let environment = getEnvironment(parameters.environments, parameters.options);
    environment = await migrateAndValidateEnvironment(environment, parameters.options.name, parameters.repair);
    // transform the provided name or env's name to be used as process name
    environment.name = (0, utils_1.transformEnvironmentName)(parameters.options.pname || environment.name);
    if (parameters.options.port !== undefined) {
        environment.port = parameters.options.port;
    }
    if (parameters.options.hostname !== undefined) {
        environment.hostname = parameters.options.hostname;
    }
    if (parameters.options.endpointPrefix !== undefined) {
        environment.endpointPrefix = parameters.options.endpointPrefix;
    }
    let dataFile = (0, path_1.join)(config_1.Config.dataPath, `${environment.name}.json`);
    // if we are building a Dockerfile, we want the data in the same folder
    if (parameters.dockerfileDir) {
        await mkdirp(parameters.dockerfileDir);
        dataFile = `${parameters.dockerfileDir}/${environment.name}.json`;
    }
    // save environment to data path
    await fs_1.promises.writeFile(dataFile, JSON.stringify(environment));
    return {
        name: environment.name,
        protocol: environment.tlsOptions.enabled ? 'https' : 'http',
        hostname: environment.hostname,
        port: environment.port,
        endpointPrefix: environment.endpointPrefix,
        dataFile
    };
};
exports.prepareData = prepareData;
/**
 * Clean the temporary data files by deleting the ones with no
 * matching running process
 *
 * @param processes
 */
const cleanDataFiles = async (processes) => {
    const files = await fs_1.promises.readdir(config_1.Config.dataPath);
    files.forEach(async (file) => {
        if (processes.findIndex((process) => `${process.name}.json` === file) === -1) {
            await fs_1.promises.unlink((0, path_1.join)(config_1.Config.dataPath, file));
        }
    });
};
exports.cleanDataFiles = cleanDataFiles;
//# sourceMappingURL=data.js.map